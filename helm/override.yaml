postgresql:
  enabled: false
redis:
  enabled: false

image:
  repository: asia-south1-docker.pkg.dev/jubilant-478904/jubilant/superset-6.0.0
  tag: "latest"

imagePullSecrets:
  - name: regcred

supersetNode:
  connections:
    redis_host: redis-headless
    db_host: postgres-headless
    db_user: postgres
    db_pass: postgres
  startupProbe:
    httpGet:
      path: /analytics/health
  livenessProbe:
    httpGet:
      path: /analytics/health
  readinessProbe:
    httpGet:
      path: /analytics/health

extraEnv:
  SUPERSET_APP_ROOT: /analytics

# bootstrapScript: |
#   #!/bin/bash
  
#   # Install system-level dependencies
#   apt-get update && apt-get install -y
#   apt-get install -y pkg-config python3-dev default-libmysqlclient-dev build-essential

#   uv pip install authlib psycopg2-binary mysqlclient prophet

#   if [ ! -f ~/bootstrap ]; then echo "Running Superset with uid {{ .Values.runAsUser }}" > ~/bootstrap; fi

configOverrides:
  my_override: |

    THEME_DEFAULT = {
        "algorithm": "default",
        "token": {
            "brandLogoUrl": "/analytics/static/assets/images/superset-logo-horiz.png",
        },
    }

    THEME_DARK = {
        "algorithm": "dark",
        "token": {
            "brandLogoUrl": "/analytics/static/assets/images/superset-logo-horiz.png",
        },
    }

    FEATURE_FLAGS = {
        'ENABLE_TEMPLATE_PROCESSING': True,
    }

    TALISMAN_CONFIG = {
        "content_security_policy": {
            "base-uri": ["'self'"],
            "default-src": ["'self'"],
            "img-src": [
                "'self'",
                "blob:",
                "data:",
                "https://apachesuperset.gateway.scarf.sh",
                "https://static.scarf.sh/",
                # "https://cdn.brandfolder.io", # Uncomment when SLACK_ENABLE_AVATARS is True  # noqa: E501
                "ows.terrestris.de",
                "https://mighzalalarab.com",
                "https://cdn.document360.io",
            ],
            "worker-src": ["'self'", "blob:"],
            "connect-src": [
                "'self'",
                "https://api.mapbox.com",
                "https://events.mapbox.com",
                "https://tile.openstreetmap.org",
                "https://tile.osm.ch",
                "https://a.basemaps.cartocdn.com",
            ],
            "object-src": "'none'",
            "style-src": [
                "'self'",
                "'unsafe-inline'",
            ],
            "script-src": ["'self'", "'strict-dynamic'"],
        },
        "content_security_policy_nonce_in": ["script-src"],
        "force_https": True,
        "session_cookie_secure": True,
    }

    # ============================================================================
    # OAuth/Keycloak Authentication Configuration
    # ============================================================================

    import base64
    import json
    import logging

    from urllib.parse import urlencode

    from flask import flash, redirect, request, session, url_for
    from flask_appbuilder.security.manager import AUTH_OAUTH
    from flask_appbuilder.security.views import AuthOAuthView, expose
    from flask_login import login_user, logout_user

    from superset.security import SupersetSecurityManager

    logger = logging.getLogger()

    # Enable OAuth authentication
    AUTH_TYPE = AUTH_OAUTH
    ENABLE_PROXY_FIX = True

    # Keycloak configuration - read from environment variables (required)
    KEYCLOAK_BASE_URL = os.getenv("KEYCLOAK_BASE_URL")
    KEYCLOAK_REALM = os.getenv("KEYCLOAK_REALM")
    KEYCLOAK_CLIENT_ID = os.getenv("KEYCLOAK_CLIENT_ID")
    KEYCLOAK_CLIENT_SECRET = os.getenv("KEYCLOAK_CLIENT_SECRET")

    # Validate that all Keycloak configuration is provided
    if not all([KEYCLOAK_BASE_URL, KEYCLOAK_REALM, KEYCLOAK_CLIENT_ID, KEYCLOAK_CLIENT_SECRET]):
        missing = []
        if not KEYCLOAK_BASE_URL:
            missing.append("KEYCLOAK_BASE_URL")
        if not KEYCLOAK_REALM:
            missing.append("KEYCLOAK_REALM")
        if not KEYCLOAK_CLIENT_ID:
            missing.append("KEYCLOAK_CLIENT_ID")
        if not KEYCLOAK_CLIENT_SECRET:
            missing.append("KEYCLOAK_CLIENT_SECRET")
        
        raise ValueError(
            f"Missing required Keycloak configuration environment variables: {', '.join(missing)}. "
            "Please set these in your environment or .env file."
        )

    # OAuth provider configuration
    # NOTE: Make sure your Keycloak client has these redirect URIs configured.
    # If SUPERSET_APP_ROOT is set (e.g., '/superset'), include it in the redirect URIs:
    # - http://localhost:8088<SUPERSET_APP_ROOT>/oauth-authorized/keycloak
    # - http://localhost:8088<SUPERSET_APP_ROOT>/oauth-authorized/keycloak/ (if using trailing slash)
    # Example with SUPERSET_APP_ROOT='/superset':
    # - http://localhost:8088/superset/oauth-authorized/keycloak
    OAUTH_PROVIDERS = [
        {
            "name": "hakimilabs",
            "icon": "fa-address-card",
            "token_key": "access_token",    
            "remote_app": {
                "client_id": KEYCLOAK_CLIENT_ID,
                "client_secret": KEYCLOAK_CLIENT_SECRET,
                "server_metadata_url": f"{KEYCLOAK_BASE_URL}/realms/{KEYCLOAK_REALM}/.well-known/openid-configuration",
                "client_kwargs": {
                    "scope": "openid email profile"
                },
            }
        }
    ]

    # CRITICAL: Disable automatic user registration
    # Users without proper roles will be rejected
    AUTH_USER_REGISTRATION = False

    # Session configuration
    # Note: session_cookie_secure is also set in TALISMAN_CONFIG above
    # The Talisman setting takes precedence when Talisman is enabled
    SESSION_COOKIE_SECURE = True  # Set to True if using HTTPS

    # Custom Security Manager
    class CustomAuthOAuthView(AuthOAuthView):
        """
        Custom OAuth view that handles Keycloak authentication
        with strict role validation
        """
        # Keep default login page - only override OAuth callback handling
        
        @expose('/oauth-authorized/<provider>')
        def oauth_authorized(self, provider):
            """
            Handle OAuth callback with strict role validation
            """
            logger.info(f"OAuth authorized callback for provider: {provider}")
            
            try:
                # Get the OAuth remote app
                if provider not in self.appbuilder.sm.oauth_remotes:
                    logger.error(f"Provider '{provider}' not found in oauth_remotes")
                    flash("Authentication failed. Invalid provider.", "danger")
                    return redirect(url_for('.login'))
                
                remote = self.appbuilder.sm.oauth_remotes[provider]
                
                # Get the token from the callback
                logger.info("Getting access token from OAuth provider...")
                token = remote.authorize_access_token()
                
                if token is None:
                    logger.error("Failed to get token from OAuth provider")
                    flash("Authentication failed. Unable to retrieve access token.", "danger")
                    return redirect(url_for('.login'))
                
                logger.info("Access token retrieved successfully")
                
                # Get user info with role validation
                logger.info("Getting user info from OAuth provider...")
                me = self.appbuilder.sm.oauth_user_info(provider, token)
                
                if me is None:
                    logger.error("Failed to get user info from OAuth provider")
                    flash("Authentication failed. Unable to retrieve user information.", "danger")
                    return redirect(url_for('.login'))
                
                # CRITICAL: Check if user has valid roles
                if not me.get('role_keys') or len(me.get('role_keys', [])) == 0:
                    logger.warning(f"User {me.get('username')} has no valid Superset roles in Keycloak")
                    flash("Access Denied: You do not have the required permissions to access Superset. Please contact your administrator.", "danger")
                    return redirect(url_for('.login'))
                
                logger.info(f"User info received: {me}")
                
                # Try to authenticate user (will only work if user exists with proper roles)
                user = self.appbuilder.sm.auth_user_oauth(me)
                
                if user is None:
                    logger.error(f"Failed to authenticate user: {me.get('username')}. User may not exist or lacks proper roles.")
                    flash("Access Denied: Your account is not authorized to access Superset. Please contact your administrator.", "danger")
                    return redirect(url_for('.login'))
                
                # Verify user has at least one role assigned
                if not user.roles or len(user.roles) == 0:
                    logger.error(f"User {user.username} has no roles assigned in Superset")
                    flash("Access Denied: Your account has no roles assigned. Please contact your administrator.", "danger")
                    return redirect(url_for('.login'))
                
                # Store ID token in session for Keycloak logout
                if isinstance(token, dict) and 'id_token' in token:
                    session['keycloak_id_token'] = token['id_token']
                    logger.info("Stored ID token in session for Keycloak logout")
                
                # Log the user in
                login_user(user, remember=False)
                logger.info(f"User logged in successfully: {user.username} with roles: {[r.name for r in user.roles]}")
                
                # Get the next URL from session or args, or redirect to home
                # Use appbuilder.get_url_for_index to respect SUPERSET_APP_ROOT
                default_next = self.appbuilder.get_url_for_index
                next_url = session.pop('next', None) or request.args.get('next', default_next)
                return redirect(next_url)
                
            except Exception as e:
                logger.error(f"OAuth authentication error: {str(e)}", exc_info=True)
                flash("Authentication failed. Please try again or contact your administrator.", "danger")
                return redirect(url_for('.login'))
        
        @expose('/logout/', methods=['GET', 'POST'])
        def logout(self):
            """
            Override logout to also logout from Keycloak (single sign-out)
            """
            logger.info("User logout requested")
            
            # Get ID token from session for Keycloak logout
            id_token = session.pop('keycloak_id_token', None)
            
            # Logout from Superset first
            logout_user()
            logger.info("Logged out from Superset")
            
            # If we have an ID token, redirect to Keycloak logout
            if id_token:
                # Build Keycloak logout URL
                logout_url = (
                    f"{KEYCLOAK_BASE_URL}/realms/{KEYCLOAK_REALM}/"
                    f"protocol/openid-connect/logout"
                )
                
                # Build redirect URI to go back to Superset login after Keycloak logout
                redirect_uri = url_for('.login', _external=True)
                
                # Build logout URL with parameters
                params = {
                    'id_token_hint': id_token,
                    'post_logout_redirect_uri': redirect_uri,
                }
                keycloak_logout_url = f"{logout_url}?{urlencode(params)}"
                
                logger.info(f"Redirecting to Keycloak logout: {keycloak_logout_url}")
                return redirect(keycloak_logout_url)
            else:
                # No ID token, just redirect to login
                logger.warning("No ID token found in session, skipping Keycloak logout")
                return redirect(url_for('.login'))


    class CustomSecurityManager(SupersetSecurityManager):
        """
        Custom security manager with:
        1. Strict role validation
        2. No default role assignment
        3. Direct OAuth redirect
        """
        authoauthview = CustomAuthOAuthView
        
        def oauth_user_info(self, provider, response=None):
            """
            Extract user info from Keycloak with STRICT role validation
            Returns None if user has no valid roles
            """
            logger.info(f"Getting user info for provider: {provider}")
            logger.info(f"Response type: {type(response)}, Response keys: {response.keys() if response and isinstance(response, dict) else 'N/A'}")
            
            if provider == "hakimilabs":
                try:
                    # Get the remote app
                    remote = self.oauth_remotes[provider]
                    
                    # The response parameter contains the token response from Keycloak
                    # Extract access token to decode and get roles
                    access_token = None
                    if response and isinstance(response, dict):
                        access_token = response.get("access_token")
                        logger.info(f"Token response keys: {list(response.keys())}")
                    
                    # Fetch user info from Keycloak userinfo endpoint
                    resp = remote.get(
                        f"{KEYCLOAK_BASE_URL}/realms/{KEYCLOAK_REALM}/protocol/openid-connect/userinfo"
                    )
                    
                    if resp.status_code != 200:
                        logger.error(f"Failed to get user info: {resp.status_code}, Response: {resp.text}")
                        return None
                    
                    user_data = resp.json()
                    logger.info(f"Raw user data from Keycloak userinfo endpoint: {user_data}")
                    
                    # Also decode the access token to get roles (roles are in the token, not userinfo)
                    token_data = {}
                    if access_token:
                        try:
                            # JWT tokens have 3 parts separated by dots: header.payload.signature
                            token_parts = access_token.split('.')
                            if len(token_parts) >= 2:
                                # Decode the payload (second part)
                                # Add padding if needed
                                payload = token_parts[1]
                                payload += '=' * (4 - len(payload) % 4)  # Add padding
                                decoded = base64.urlsafe_b64decode(payload)
                                token_data = json.loads(decoded)
                                logger.info(f"Decoded token data keys: {list(token_data.keys())}")
                                logger.info(f"Token contains realm_access: {'realm_access' in token_data}")
                                logger.info(f"Token contains resource_access: {'resource_access' in token_data}")
                        except Exception as e:
                            logger.warning(f"Could not decode access token: {e}")
                    
                    # Merge userinfo data with token data (token has roles, userinfo has user details)
                    combined_data = {**user_data, **token_data}
                    logger.info(f"Combined data keys: {list(combined_data.keys())}")
                    
                    # Extract user information
                    username = combined_data.get("preferred_username") or combined_data.get("email", "").split("@")[0]
                    email = combined_data.get("email", "")
                    first_name = combined_data.get("given_name", "")
                    last_name = combined_data.get("family_name", "")
                    
                    # CRITICAL: Extract roles with strict validation
                    # Pass both userinfo and token data to extract roles
                    role_keys = self._extract_roles_from_token(combined_data)
                    
                    # REJECT users without any valid roles
                    if not role_keys or len(role_keys) == 0:
                        logger.warning(f"User {username} has no valid Superset roles. Rejecting authentication.")
                        logger.warning("To fix: Assign roles in Keycloak (superset-admin, alpha, or gamma)")
                        return None
                    
                    logger.info(f"Extracted user info - username: {username}, email: {email}, roles: {role_keys}")
                    
                    return {
                        "username": username,
                        "email": email,
                        "first_name": first_name,
                        "last_name": last_name,
                        "role_keys": role_keys
                    }
                    
                except Exception as e:
                    logger.error(f"Error getting user info: {str(e)}", exc_info=True)
                    return None
            
            return None
        
        def _extract_roles_from_token(self, user_data):
            """
            Extract and map Keycloak roles to Superset roles
            Returns EMPTY LIST if no valid roles found (user will be rejected)
            """
            roles = []
            
            logger.info("Extracting roles from token/user_data...")
            
            # Check resource_access (client-specific roles)
            if "resource_access" in user_data:
                logger.info(f"resource_access keys: {list(user_data['resource_access'].keys())}")
                
                # Check client-specific roles
                if KEYCLOAK_CLIENT_ID in user_data["resource_access"]:
                    client_roles = user_data["resource_access"][KEYCLOAK_CLIENT_ID].get("roles", [])
                    logger.info(f"Client roles for {KEYCLOAK_CLIENT_ID}: {client_roles}")
                    
                    if "superset-admin" in client_roles:
                        roles.append("Admin")
                    if "superset-alpha" in client_roles:
                        roles.append("Alpha")
                    if "superset-gamma" in client_roles:
                        roles.append("Gamma")
                        roles.append("all_datasource_access")
            
            # Remove duplicates
            roles = list(set(roles))
            
            # CRITICAL: Return empty list if no roles found
            # This will cause authentication to fail
            if not roles:
                logger.warning("No valid Superset roles found in Keycloak token. User will be rejected.")
                logger.warning("Expected roles in Keycloak: superset-admin, alpha, or gamma (for Admin, Alpha, Gamma respectively)")
                return []
            
            logger.info(f"Final mapped roles: {roles}")
            return roles
        
        def auth_user_oauth(self, userinfo):
            """
            Override to prevent user creation and enforce strict role validation
            Only allow existing users with proper roles to login
            """
            # Get existing user
            user = self.find_user(username=userinfo['username'])
            
            if user is None:
                # Check if we should allow registration
                # Since AUTH_USER_REGISTRATION = False, we manually handle this
                
                # ONLY create user if they have valid roles from Keycloak
                if not userinfo.get('role_keys') or len(userinfo.get('role_keys', [])) == 0:
                    logger.warning(f"Cannot create user {userinfo['username']} - no valid roles")
                    return None
                
                # Create user with the roles from Keycloak
                user = self.add_user(
                    username=userinfo['username'],
                    first_name=userinfo.get('first_name', ''),
                    last_name=userinfo.get('last_name', ''),
                    email=userinfo['email'],
                    role=self.find_role(userinfo['role_keys'][0])  # Assign first role
                )
                
                if user:
                    # Assign all additional roles
                    for role_name in userinfo['role_keys']:
                        role = self.find_role(role_name)
                        if role and role not in user.roles:
                            user.roles.append(role)
                    self.update_user(user)
                    logger.info(f"Created new user: {user.username} with roles: {userinfo['role_keys']}")
            else:
                # Update existing user's roles based on Keycloak
                if userinfo.get('role_keys'):
                    # Clear existing roles and assign new ones from Keycloak
                    user.roles = []
                    for role_name in userinfo['role_keys']:
                        role = self.find_role(role_name)
                        if role:
                            user.roles.append(role)
                    
                    # Update user info
                    user.first_name = userinfo.get('first_name', user.first_name)
                    user.last_name = userinfo.get('last_name', user.last_name)
                    user.email = userinfo.get('email', user.email)
                    
                    self.update_user(user)
                    logger.info(f"Updated user: {user.username} with roles: {userinfo['role_keys']}")
                else:
                    logger.warning(f"User {user.username} has no roles from Keycloak")
                    return None
            
            return user

    # Use custom security manager
    CUSTOM_SECURITY_MANAGER = CustomSecurityManager
